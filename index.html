<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Camera + Wake Lock + Remember + Gesture + Volume Bar</title>

<style>
  :root { --bg:#111; --fg:#eee; --card:#181818; --line:#333; }
  *{ box-sizing:border-box; }

  body{
    margin:0;
    font-family:system-ui,-apple-system,"Segoe UI",sans-serif;
    background:var(--bg);
    color:var(--fg);
    min-height:100vh;
    display:flex;
    flex-direction:column;
  }

  #topBar{
    padding:10px 12px;
    display:flex;
    gap:10px;
    align-items:center;
    border-bottom:1px solid var(--line);
    font-size:14px;
    flex-wrap:wrap;
  }
  #status{ opacity:.85; }

  #wrap{
    padding:12px;
    display:flex;
    flex-direction:column;
    gap:12px;
    flex:1;
    min-height:0;
  }

  #videoCard{
    background:#000;
    border-radius:12px;
    overflow:hidden;
    border:1px solid #222;
    position:relative;
    height:50vh;
    min-height:220px;
  }

  video{
    width:100%;
    height:100%;
    display:block;
    background:#000;
    object-fit:contain; /* no crop */
    transform-origin:center;
  }
  video.mirror{ transform:scaleX(-1); }

  #overlay{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    pointer-events:none;
  }

  .panel{
    background:var(--card);
    border:1px solid #222;
    border-radius:12px;
    padding:12px;
    display:flex;
    flex-direction:column;
    gap:10px;
  }

  .row{
    display:flex;
    gap:10px;
    align-items:center;
    flex-wrap:wrap;
  }

  label{
    min-width:140px;
    font-size:13px;
    opacity:.95;
  }

  select{
    flex:1;
    min-width:200px;
    padding:10px 12px;
    border-radius:10px;
    border:1px solid #444;
    background:#111;
    color:#fff;
    font-size:13px;
  }

  button{
    height:38px;
    padding:0 14px;
    border-radius:10px;
    border:1px solid #444;
    background:#2a2a2a;
    color:#fff;
    font-size:13px;
    cursor:pointer;
  }
  button:hover{ background:#343434; }
  button:active{ background:#3f3f3f; }
  .active{
    background:#0a6cff !important;
    border-color:#0a6cff !important;
  }

  .pill{
    display:inline-flex;
    align-items:center;
    gap:8px;
    padding:6px 10px;
    border:1px solid #2a2a2a;
    border-radius:999px;
    background:#141414;
    font-size:12px;
    opacity:.95;
    height:38px; /* match button height */
  }

  input[type="range"]{ flex:1; min-width:190px; }
  .valueLabel{
    min-width:110px;
    text-align:right;
    font-size:12px;
    opacity:.9;
  }

  .divider{ height:1px; background:#2a2a2a; margin:6px 0; }
  .hint{ opacity:.85; font-size:12px; }

  .swatch{
    width:18px; height:18px;
    border-radius:6px;
    border:1px solid #3a3a3a;
    background:#fff;
    flex:0 0 auto;
  }
</style>
</head>

<body>
<div id="topBar">
  <strong>Camera</strong>
  <span id="status"></span>
  <span class="pill">Gesture: <span id="gestureText">‚Äî</span></span>
</div>

<div id="wrap">
  <div id="videoCard">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <div class="panel">
    <div class="row">
      <label>Camera</label>
      <select id="cameraSelect"></select>
    </div>

    <div class="row">
      <button id="btnRefresh">Refresh</button>
      <button id="btnFlash">Flash OFF</button>
      <button id="btnMirror">Mirror OFF</button>
      <button id="btnWake">Wake Lock OFF</button>
      <button id="btnStop">Stop</button>

      <!-- MOVED HERE -->
      <span class="pill">Vol: <span id="volText">50%</span></span>
    </div>

    <div class="row hint">
      ‚úã Open Palm ‚Ä¢ ‚òùÔ∏è One Finger (Index) ‚Ä¢ üññ Three Fingers ‚Ä¢ üëç Thumbs Up ‚Ä¢ üëé Thumbs Down ‚Ä¢ ‚úåÔ∏è Peace ‚Ä¢ ü´∞ Mini Love
    </div>

    <div class="divider"></div>

    <div class="row">
      <label>Line Color Hue</label>
      <span class="swatch" id="lineSwatch"></span>
      <input id="lineHue" type="range" min="0" max="360">
      <span class="valueLabel" id="lineHueV"></span>
    </div>

    <div class="row">
      <label>Dot Color Hue</label>
      <span class="swatch" id="dotSwatch"></span>
      <input id="dotHue" type="range" min="0" max="360">
      <span class="valueLabel" id="dotHueV"></span>
    </div>

    <div class="row">
      <label>Line Thickness</label>
      <input id="lineSize" type="range" min="1" max="10" step="1">
      <span class="valueLabel" id="lineSizeV"></span>
    </div>

    <div class="row">
      <label>Dot Size</label>
      <input id="dotSize" type="range" min="1" max="12" step="1">
      <span class="valueLabel" id="dotSizeV"></span>
    </div>
  </div>
</div>

<!-- MediaPipe Hands -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

<script>
/* =========================
   LocalStorage helpers
========================= */
const LS = {
  camId:     "cam_last_deviceId",
  mirror:    "cam_mirror",
  wake:      "cam_wakelock",
  torch:     "cam_torch",
  lineHue:   "hand_line_hue",
  dotHue:    "hand_dot_hue",
  lineSize:  "hand_line_size",
  dotSize:   "hand_dot_size",
  vol:       "gesture_volume"
};
const save = (k,v)=>{ try{ localStorage.setItem(k, JSON.stringify(v)); }catch(e){} };
const load = (k,def)=>{ try{ const v=localStorage.getItem(k); return v!==null?JSON.parse(v):def; }catch(e){ return def; } };

/* =========================
   Elements / state
========================= */
const video = document.getElementById("video");
const overlay = document.getElementById("overlay");
const octx = overlay.getContext("2d");
const videoCard = document.getElementById("videoCard");

const statusEl = document.getElementById("status");
const gestureText = document.getElementById("gestureText");
const volText = document.getElementById("volText");
const cameraSelect = document.getElementById("cameraSelect");

const btnRefresh = document.getElementById("btnRefresh");
const btnFlash   = document.getElementById("btnFlash");
const btnMirror  = document.getElementById("btnMirror");
const btnWake    = document.getElementById("btnWake");
const btnStop    = document.getElementById("btnStop");

const lineHueS = document.getElementById("lineHue");
const dotHueS  = document.getElementById("dotHue");
const lineSizeS= document.getElementById("lineSize");
const dotSizeS = document.getElementById("dotSize");

const lineHueV = document.getElementById("lineHueV");
const dotHueV  = document.getElementById("dotHueV");
const lineSizeV= document.getElementById("lineSizeV");
const dotSizeV = document.getElementById("dotSizeV");

const lineSwatch = document.getElementById("lineSwatch");
const dotSwatch  = document.getElementById("dotSwatch");

let stream=null, track=null;
let torchOn    = load(LS.torch, false);
let mirrorOn   = load(LS.mirror, false);
let wakeWanted = load(LS.wake, true);

let lineHue  = load(LS.lineHue, 190);
let dotHue   = load(LS.dotHue,  20);
let lineSize = load(LS.lineSize, 3);
let dotSize  = load(LS.dotSize,  4);

let volume = load(LS.vol, 50);
volume = Math.max(0, Math.min(100, Number(volume)||50));
volText.textContent = volume + "%";

let wakeLock = null;

function setStatus(msg){ statusEl.textContent = msg; }

function applyMirrorUI(){
  video.classList.toggle("mirror", mirrorOn);
  btnMirror.textContent = mirrorOn ? "Mirror ON" : "Mirror OFF";
  btnMirror.classList.toggle("active", mirrorOn);
}

function applyWakeUI(isOn){
  btnWake.textContent = isOn ? "Wake Lock ON" : "Wake Lock OFF";
  btnWake.classList.toggle("active", isOn);
}

function applyTorchUI(isOn){
  btnFlash.textContent = isOn ? "Flash ON" : "Flash OFF";
  btnFlash.classList.toggle("active", isOn);
}

/* =========================
   Hand style
========================= */
function lineColor(a=1){ return `hsla(${lineHue},100%,55%,${a})`; }
function dotColor(a=1){  return `hsla(${dotHue},100%,55%,${a})`; }

function updateSwatches(){
  lineSwatch.style.background = lineColor(1);
  dotSwatch.style.background  = dotColor(1);
}

function setSliderUI(){
  lineHueS.value=lineHue; dotHueS.value=dotHue;
  lineSizeS.value=lineSize; dotSizeS.value=dotSize;
  lineHueV.textContent=`${lineHue}¬∞`;
  dotHueV.textContent =`${dotHue}¬∞`;
  lineSizeV.textContent=`${lineSize}px`;
  dotSizeV.textContent =`${dotSize}px`;
  updateSwatches();
}
setSliderUI();

lineHueS.oninput = e=>{ lineHue=+e.target.value; lineHueV.textContent=`${lineHue}¬∞`; save(LS.lineHue,lineHue); updateSwatches(); };
dotHueS.oninput  = e=>{ dotHue=+e.target.value;  dotHueV.textContent =`${dotHue}¬∞`; save(LS.dotHue,dotHue); updateSwatches(); };
lineSizeS.oninput= e=>{ lineSize=+e.target.value; lineSizeV.textContent=`${lineSize}px`; save(LS.lineSize,lineSize); };
dotSizeS.oninput = e=>{ dotSize=+e.target.value;  dotSizeV.textContent =`${dotSize}px`; save(LS.dotSize,dotSize); };

/* =========================
   Wake Lock
========================= */
async function requestWakeLock(){
  if(!("wakeLock" in navigator)){ applyWakeUI(false); return false; }
  try{
    wakeLock = await navigator.wakeLock.request("screen");
    wakeLock.addEventListener("release", ()=>applyWakeUI(false));
    applyWakeUI(true);
    return true;
  }catch(e){
    applyWakeUI(false);
    return false;
  }
}
async function releaseWakeLock(){
  try{ if(wakeLock){ await wakeLock.release(); wakeLock=null; } }catch(e){}
  applyWakeUI(false);
}
document.addEventListener("visibilitychange", async ()=>{
  if(document.visibilityState==="visible" && wakeWanted) await requestWakeLock();
});

/* =========================
   Torch
========================= */
async function setTorch(on){
  if(!track){ torchOn=false; save(LS.torch,torchOn); applyTorchUI(false); return false; }
  const caps = track.getCapabilities?.();
  if(!caps || !("torch" in caps)){
    torchOn=false; save(LS.torch,torchOn); applyTorchUI(false);
    alert("Flash not supported on this device/camera");
    return false;
  }
  try{
    await track.applyConstraints({ advanced:[{ torch: !!on }] });
    torchOn=!!on; save(LS.torch,torchOn); applyTorchUI(torchOn);
    return true;
  }catch(err){
    torchOn=false; save(LS.torch,torchOn); applyTorchUI(false);
    alert("Flash failed: " + err.name);
    return false;
  }
}

/* =========================
   Gesture + Volume
========================= */
let hands=null, handsReady=false;
let lastGesture="none", lastGestureTs=0;

// volume tuning
const VOL_STEP = 2;
const VOL_COOLDOWN_MS = 120;
let lastVolTick = 0;

function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }

/* UPDATED gestures:
   - one: index only
   - three: index+middle+ring
   - mini_love: thumb tip near index tip (heuristic)
*/
function classifyGesture(lm){
  const wrist = lm[0];

  const tips = { thumb: lm[4], index: lm[8], middle: lm[12], ring: lm[16], pinky: lm[20] };
  const pips = { index: lm[6], middle: lm[10], ring: lm[14], pinky: lm[18], thumb: lm[3] };
  const mcps = { index: lm[5], middle: lm[9] };

  const extIndex  = dist(tips.index, wrist)  > dist(pips.index, wrist)  * 1.05;
  const extMiddle = dist(tips.middle, wrist) > dist(pips.middle, wrist) * 1.05;
  const extRing   = dist(tips.ring, wrist)   > dist(pips.ring, wrist)   * 1.05;
  const extPinky  = dist(tips.pinky, wrist)  > dist(pips.pinky, wrist)  * 1.05;

  const extThumb  = dist(tips.thumb, mcps.index) > dist(pips.thumb, mcps.index) * 1.03;

  const thumbOnly = extThumb && !extIndex && !extMiddle && !extRing && !extPinky;

  const thumbUpCond   = thumbOnly && (tips.thumb.y < wrist.y - 0.05);
  const thumbDownCond = thumbOnly && (tips.thumb.y > wrist.y + 0.05);

  const peace = !extThumb && extIndex && extMiddle && !extRing && !extPinky;
  const palm  = extIndex && extMiddle && extRing && extPinky;

  const one   = extIndex && !extMiddle && !extRing && !extPinky && !extThumb;
  const three = extIndex && extMiddle && extRing && !extPinky && !extThumb;

  // mini love heuristic: thumb tip close to index tip (normalize by hand size)
  const dTI = dist(tips.thumb, tips.index);
  const handScale = dist(wrist, mcps.middle) || 1e-6;
  const dScaled = dTI / handScale;
  const miniLove = (dScaled < 0.55) && !palm && !peace && !thumbOnly && (extThumb || extIndex);

  if(thumbUpCond)   return "thumbs_up";
  if(thumbDownCond) return "thumbs_down";
  if(miniLove)      return "mini_love";
  if(three)         return "three";
  if(one)           return "one";
  if(peace)         return "peace";
  if(palm)          return "open_palm";
  return "none";
}

function gestureInfo(code){
  switch(code){
    case "open_palm":   return { icon:"‚úã", label:"Open Palm" };
    case "one":         return { icon:"‚òùÔ∏è", label:"One (Index)" };
    case "three":       return { icon:"üññ", label:"Three" };
    case "thumbs_up":   return { icon:"üëç", label:"Thumbs Up" };
    case "thumbs_down": return { icon:"üëé", label:"Thumbs Down" };
    case "peace":       return { icon:"‚úåÔ∏è", label:"Peace" };
    case "mini_love":   return { icon:"ü´∞", label:"Mini Love" };
    default:            return { icon:"",  label:"‚Äî" };
  }
}

function setVolume(v){
  volume = Math.max(0, Math.min(100, v));
  volText.textContent = volume + "%";
  save(LS.vol, volume);
}
function bumpVolume(dir){ setVolume(volume + dir * VOL_STEP); }

/* =========================
   Overlay mapping + drawing
========================= */
function getContainRect(){
  const cw = videoCard.clientWidth;
  const ch = videoCard.clientHeight;
  const vw = video.videoWidth || 1;
  const vh = video.videoHeight || 1;

  const scale = Math.min(cw / vw, ch / vh);
  const dw = vw * scale;
  const dh = vh * scale;
  const dx = (cw - dw) / 2;
  const dy = (ch - dh) / 2;
  return { cw, ch, dx, dy, dw, dh };
}

function resizeOverlayToCard(){
  const rect = videoCard.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  const W = Math.max(1, Math.round(rect.width * dpr));
  const H = Math.max(1, Math.round(rect.height * dpr));
  if(overlay.width !== W || overlay.height !== H){
    overlay.width = W;
    overlay.height = H;
  }
}

function drawRoundedRect(x,y,w,h,r){
  octx.beginPath();
  octx.moveTo(x+r, y);
  octx.lineTo(x+w-r, y);
  octx.quadraticCurveTo(x+w, y, x+w, y+r);
  octx.lineTo(x+w, y+h-r);
  octx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
  octx.lineTo(x+r, y+h);
  octx.quadraticCurveTo(x, y+h, x, y+h-r);
  octx.lineTo(x, y+r);
  octx.quadraticCurveTo(x, y, x+r, y);
  octx.closePath();
}

function drawGestureBadge(mappedLandmarks, gestureCode){
  const info = gestureInfo(gestureCode);
  if(info.label === "‚Äî") return;

  const wrist = mappedLandmarks[0];
  let x = wrist.x * overlay.width;
  let y = wrist.y * overlay.height;

  x += 14; y -= 18;

  const text = `${info.icon} ${info.label}`;
  octx.save();
  octx.font = "bold 18px system-ui, -apple-system, Segoe UI, Arial";
  octx.textBaseline = "middle";

  const pad = 10;
  const w = Math.ceil(octx.measureText(text).width) + pad*2;
  const h = 34;

  x = Math.max(6, Math.min(overlay.width - w - 6, x));
  y = Math.max(6, Math.min(overlay.height - h - 6, y));

  octx.fillStyle = "rgba(0,0,0,0.55)";
  octx.strokeStyle = lineColor(0.9);
  octx.lineWidth = 2;
  drawRoundedRect(x,y,w,h,10);
  octx.fill();
  octx.stroke();

  octx.fillStyle = "#fff";
  octx.fillText(text, x+pad, y+h/2);
  octx.restore();
}

function drawVolCircleLabel(cx, cy, text){
  const r = 20;
  octx.save();
  octx.beginPath();
  octx.arc(cx, cy, r, 0, Math.PI*2);
  octx.fillStyle = "rgba(0,0,0,0.65)";
  octx.fill();
  octx.lineWidth = 2.5;
  octx.strokeStyle = "rgba(255,255,255,0.35)";
  octx.stroke();
  octx.font = "bold 13px system-ui, -apple-system, Segoe UI, Arial";
  octx.textAlign = "center";
  octx.textBaseline = "middle";
  octx.fillStyle = "#fff";
  octx.fillText(text, cx, cy);
  octx.restore();
}

function drawVolumeBar(mappedLandmarks){
  const p = mappedLandmarks[4]; // thumb tip
  let x = p.x * overlay.width;
  let y = p.y * overlay.height;

  const barW = 18;
  const barH = 130;

  x += 18;
  y -= barH/2;

  x = Math.max(8, Math.min(overlay.width - barW - 8, x));
  y = Math.max(8, Math.min(overlay.height - barH - 8, y));

  const fillH = Math.round((volume/100) * barH);
  const fy = y + (barH - fillH);

  octx.save();

  octx.fillStyle = "rgba(0,0,0,0.45)";
  octx.strokeStyle = "rgba(255,255,255,0.35)";
  octx.lineWidth = 2;
  drawRoundedRect(x,y,barW,barH,10);
  octx.fill();
  octx.stroke();

  octx.fillStyle = "rgba(0,180,255,0.85)";
  drawRoundedRect(x,fy,barW,fillH,10);
  octx.fill();

  const label = volume + "%";
  const cx = x + barW/2;
  const cy = Math.max(26, y - 18);
  drawVolCircleLabel(cx, cy, label);

  octx.restore();
}

/* =========================
   Hand style functions (must be after lineHue/dotHue vars exist)
========================= */
function lineColor(a=1){ return `hsla(${lineHue},100%,55%,${a})`; }
function dotColor(a=1){  return `hsla(${dotHue},100%,55%,${a})`; }

/* =========================
   MediaPipe hands
========================= */
function initHands(){
  hands = new Hands({
    locateFile: (file)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
  });
  hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.6,
    minTrackingConfidence: 0.6
  });

  hands.onResults((results)=>{
    resizeOverlayToCard();
    octx.setTransform(1,0,0,1,0,0);
    octx.clearRect(0,0,overlay.width, overlay.height);

    if(!(results.multiHandLandmarks && results.multiHandLandmarks.length)){
      const now=performance.now();
      if(now-lastGestureTs>400) lastGesture="none";
      const gi = gestureInfo(lastGesture);
      gestureText.textContent = gi.icon ? `${gi.icon} ${gi.label}` : "‚Äî";
      return;
    }

    const lm = results.multiHandLandmarks[0];
    const { cw, ch, dx, dy, dw, dh } = getContainRect();

    const mapped = lm.map(p => {
      let nx = (dx + p.x * dw) / cw;
      const ny = (dy + p.y * dh) / ch;
      if(mirrorOn) nx = 1 - nx;
      return { x:nx, y:ny, z:p.z };
    });

    drawConnectors(octx, mapped, HAND_CONNECTIONS, { color: lineColor(0.95), lineWidth: lineSize });
    drawLandmarks(octx, mapped, { color: dotColor(1), radius: dotSize });

    const g = classifyGesture(lm);
    const now = performance.now();

    if(g !== "none"){
      if(g !== lastGesture){ lastGesture = g; lastGestureTs = now; }
      else lastGestureTs = now;
    }else{
      if(now - lastGestureTs > 400) lastGesture = "none";
    }

    const isThumb = (lastGesture === "thumbs_up" || lastGesture === "thumbs_down");

    if(isThumb && (now - lastVolTick) >= VOL_COOLDOWN_MS){
      lastVolTick = now;
      bumpVolume(lastGesture === "thumbs_up" ? +1 : -1);
    }

    drawGestureBadge(mapped, lastGesture);

    if(isThumb){
      drawVolumeBar(mapped);
    }

    const gi = gestureInfo(lastGesture);
    gestureText.textContent = gi.icon ? `${gi.icon} ${gi.label}` : "‚Äî";
  });

  handsReady = true;
}

let gestureLoopRunning=false;
async function gestureLoop(){
  if(!gestureLoopRunning) return;
  if(video.readyState >= 2 && video.videoWidth && video.videoHeight && handsReady){
    try{ await hands.send({ image: video }); }catch(e){}
  }
  requestAnimationFrame(gestureLoop);
}

function startGesture(){
  if(!hands) initHands();
  gestureLoopRunning=true;
  requestAnimationFrame(gestureLoop);
}
function stopGesture(){
  gestureLoopRunning=false;
  octx.clearRect(0,0,overlay.width,overlay.height);
  gestureText.textContent="‚Äî";
  lastGesture="none";
}

/* =========================
   Camera
========================= */
function stopCamera(){
  stopGesture();
  if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; track=null; }
  video.srcObject=null;
  setStatus("Stopped");
  applyTorchUI(false);
}

async function startCamera(deviceId){
  try{
    stopCamera();
    setStatus("Starting camera‚Ä¶");

    const constraints = {
      video:{
        deviceId: deviceId ? { exact: deviceId } : undefined,
        facingMode: "environment",
        width:{ ideal:1920 },
        height:{ ideal:1080 }
      },
      audio:false
    };

    stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    track = stream.getVideoTracks()[0];

    if(deviceId) save(LS.camId, deviceId);

    applyMirrorUI();

    if(torchOn) await setTorch(true);
    else applyTorchUI(false);

    setStatus("Camera running ‚úÖ");

    if(wakeWanted) await requestWakeLock();
    else await releaseWakeLock();

    startGesture();
  }catch(err){
    console.error(err);
    setStatus("Camera error: " + err.name);
    alert("Camera error: " + err.name);
  }
}

async function listCameras(){
  setStatus("Listing cameras‚Ä¶");

  try{
    const tmp = await navigator.mediaDevices.getUserMedia({video:true});
    tmp.getTracks().forEach(t=>t.stop());
  }catch(e){}

  const devices = await navigator.mediaDevices.enumerateDevices();
  const cams = devices.filter(d=>d.kind==="videoinput");

  cameraSelect.innerHTML="";
  cams.forEach((cam,i)=>{
    const opt=document.createElement("option");
    opt.value=cam.deviceId;
    opt.textContent=cam.label || `Camera ${i+1}`;
    cameraSelect.appendChild(opt);
  });

  cameraSelect.onchange = ()=>startCamera(cameraSelect.value);

  if(!cams.length){ setStatus("No camera found"); return; }

  const lastId = load(LS.camId, null);
  let preferred = cams[0];

  if(lastId && cams.some(c=>c.deviceId===lastId)) preferred = cams.find(c=>c.deviceId===lastId);
  else {
    const back = cams.find(c => (c.label||"").toLowerCase().match(/back|rear|environment/));
    if(back) preferred = back;
  }

  cameraSelect.value = preferred.deviceId;
  await startCamera(preferred.deviceId);
}

/* =========================
   Buttons
========================= */
btnRefresh.onclick = ()=>listCameras();

btnStop.onclick = async ()=>{
  stopCamera();
  await releaseWakeLock();
};

btnMirror.onclick = ()=>{
  mirrorOn = !mirrorOn;
  save(LS.mirror, mirrorOn);
  applyMirrorUI();
};

btnFlash.onclick = async ()=>{ await setTorch(!torchOn); };

btnWake.onclick = async ()=>{
  wakeWanted = !wakeWanted;
  save(LS.wake, wakeWanted);
  if(wakeWanted) await requestWakeLock();
  else await releaseWakeLock();
};

/* =========================
   Init
========================= */
applyMirrorUI();
applyTorchUI(torchOn);
applyWakeUI(false);
updateSwatches();

(async function init(){
  if(!navigator.mediaDevices?.getUserMedia){
    alert("Camera API not supported");
    return;
  }
  await listCameras();
})();
</script>
</body>
</html>
